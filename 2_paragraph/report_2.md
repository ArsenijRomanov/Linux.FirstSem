# Отчёт №2

## Цель работы
1. Научиться писать простые shell-скрипты на Bash: обработка аргументов, циклы, проверка ошибок.
2. Освоить перенаправления/конвейер и запуск процессов в фоне (`&`, `wait`).
3. Применить утилиты `find`, `convert` (ImageMagick), `awk` для решения практических задач.

## Среда выполнения
- ОС: **Ubuntu**
- Для конвертации изображений установлен пакет ImageMagick (`convert`).

---

## Ход работы

## 1) Конвертация изображений

### Задание
Написать скрипт, который преобразует переданные в него файлы в формат PNG, используя `convert`.
Для теста скачать несколько изображений из интернета (например, через `wget`).

### Решение
**Скрипт `1.sh`:**
```bash
#!/bin/bash

if [ $# -eq 0 ]; then
	echo -e "\033[31mError: No files provided.\033[0m"
	exit 1
fi

for file in "$@"; do

	if [ -f "$file" ]; then
		convert "$file" "${file%.*}-converted.png"
		echo -e "\033[32mFile $file converted to ${file%.*}-converted.png\033[0m"

	else
		echo -e "\033[31mError: File $file not found.\033[0m"

	fi
done
```

### Пояснение
- `"$@"` — список всех аргументов скрипта (имена файлов), корректно работает с пробелами при кавычках.
- Проверка `if [ $# -eq 0 ]` — если аргументов нет, выводится ошибка и выполнение прекращается.
- `convert "$file" ...` — конвертация изображения в PNG (утилита ImageMagick).
- `"${file%.*}"` — удаление расширения файла (shell-подстановка), затем добавляется `-converted.png`.

### Пример запуска
```bash
chmod +x 1.sh
./1.sh image1.jpg image2.jpg
```

---

## 2) Мониторинг

### Задание
Скрипт должен вывести показания всех температурных датчиков, поддерживаемых ядром.
Нужно найти файлы в `/sys`, начинающиеся на `temp` и заканчивающиеся на `input`, и вывести их содержимое.

### Решение
```bash
#!/bin/bash

find /sys -type f -name "temp*input" 2>/dev/null | while read sensor_file; do

	echo "Sensor: $sensor_file"

	awk '{printf("%.1f°C\n",$1/1000)}' "$sensor_file"
	echo ""
done
```

### Пояснение
- `find /sys -type f -name "temp*input"` — поиск файлов датчиков температуры.
- `2>/dev/null` — подавление ошибок доступа.
- `| while read sensor_file; do ... done` — чтение найденных путей построчно через конвейер.
- `awk '{printf("%.1f°C\n",$1/1000)}'` — форматирование значения

---

## 3) Параллельная обработка

### Задание
Переписать скрипт конвертации так, чтобы несколько изображений обрабатывались параллельно.
Использовать запуск в фоне `&` и команду `wait`.

### Решение
```bash
#!/bin/bash

if [ $# -eq 0 ]; then
	echo -e "\033[31mError: No files provided.\033[0m"
	exit 1
fi

pids=()
files=()

for file in "$@"; do

	if [ -f "$file" ]; then

		if [[ "$file" =~ \.(jpg|jpeg)$ ]]; then
			convert "$file" "${file%.*}-converted.png" &
			pids+=($!)
			files+=("$file")

		else
			echo -e "\033[31mError: $file is not a valid image file.\033[0m"
		fi

	else
		echo -e "\033[31mError: File $file not found.\033[0m"
	fi
done

for i in "${!pids[@]}"; do
	wait ${pids[$i]}
	if [ $? -eq 0 ]; then
		echo -e "\033[32mConversion completed for file: ${files[$i]}.\033[0m"
	else
		echo -e "\033[31mError occurred during conversion for file: ${files[$i]}.\033[0m"
	fi
done
```

### Пояснение
- `convert ... &` — запуск конвертации в **фоновом режиме**.
- `$!` — PID последнего фонового процесса; сохраняется в массив `pids`.
- `wait PID` — ожидание завершения фонового процесса; после `wait` проверяется код возврата (`$?`).
---

## 4) Конвейер

### Задание
Скрипт должен:
1) найти JPG-файлы,
2) конвертировать их в PNG,
и сделать так, чтобы **поиск и конвертация были звеньями конвейера**.

Также требуется ответить: будет ли такой скрипт быстрее параллельного для большого количества файлов (например, тысячи).

### Решение
**Скрипт:**
```bash
#!/bin/bash

if [ $# -eq 0 ]; then
	echo -e "\033[31mError: No directory provided.\033[0m"
	exit 1
fi

if [ ! -d "$1" ]; then
	echo -e "\033[31mError: $1 is not a valid directory.\033[0m"
	exit 1
fi

find "$1" -type f -iname "*.jpg" | while read file; do
	convert "$file" "${file%.*}.png"
	echo -e "\033[32mConverted $file to ${file%.*}-converted.png\033[0m"
done
```

### Пояснение
- `find ... | while read file; do ... done` — конвейер: `find` выдаёт список файлов, цикл читает их по одному и запускает `convert`.
- Скрипт проверяет наличие аргумента и то, что это **директория**.

**Замечание:** команда `convert` создаёт файл `"${file%.*}.png"`, а строка `echo` выводит `...-converted.png` — это только сообщение, его можно привести к фактическому имени результата.

### Ответ на вопрос о производительности
Для тысяч файлов конвейерный вариант, как правило, **не быстрее** параллельного:
- скрипт из 3 задачи выполняет конвертацию **последовательно** (по одному файлу).
- скрипт из 4 задачи может выполнять несколько конвертаций одновременно, что обычно быстрее для CPU-нагруженной операции `convert`.
- При этом конвейерный вариант удобен тем, что не хранит список файлов в памяти и начинает обработку сразу по мере нахождения файлов.

---

## Вывод
Были реализованы shell-скрипты для: массовой конвертации изображений, вывода температурных датчиков из `sysfs`, параллельной обработки с использованием `&` и `wait`, а также конвейерной обработки через `find | while read`. Получены навыки работы с аргументами, циклами, проверкой ошибок и базовыми механизмами оболочки.
